package JAC::OCS::Config::POL;

=head1 NAME

JAC::OCS::Config::POL - Parse and modify OCS Polarimeter configurations

=head1 SYNOPSIS

  use JAC::OCS::Config::POL;

  $pol = new JAC::OCS::Config::POL( File => 'pol.ent');

  $mode = $pol->is_spinning;
  @angles = $pol->discrete_angles;
  $speed = $pol->spin_speed();
  $sys = $pol->system();
  $motion = $pol->motion;

=head1 DESCRIPTION

This class can be used to parse and modify the header configuration
information present in the POL_CONFIG element of an OCS configuration.

=cut

use 5.006;
use strict;
use Carp;
use warnings;
use XML::LibXML;
use Astro::Coords::Angle;

use JAC::OCS::Config::Error qw| :try |;

use JAC::OCS::Config::XMLHelper qw(
                                   find_children
                                   find_attr
                                   indent_xml_string
                                   get_pcdata
                                  );
use JAC::OCS::Config::TCS::Generic qw (
                                        find_pa
                                        pa_to_xml
                                     );

use base qw/ JAC::OCS::Config::CfgBase /;

use vars qw/ $VERSION /;

$VERSION = sprintf("%d", q$Revision: 14392 $ =~ /(\d+)/);

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new POL configuration object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::POL( File => $file );
  $cfg = new JAC::OCS::Config::POL( XML => $xml );
  $cfg = new JAC::OCS::Config::POL( DOM => $dom );

The method will die if no arguments are supplied.

=cut

sub new {
  my $self = shift;

  # Now call base class with all the supplied options +
  # extra initialiser
  return $self->SUPER::new( @_, 
			    $JAC::OCS::Config::CfgBase::INITKEY => {
                                                                    DiscreteAngles => [],
								   }
			  );
}

=back

=head2 Accessor Methods

=over 4

=item B<is_spinning>

Indicates whether the polarimeter is in spinning mode (true) or
step and integrate mode (false).

  $isspin = $pol->is_spinning();

A spin speed is only available if true, and discrete angles are
only available if false.

=cut

sub is_spinning {
  my $self = shift;
  if (@_) {
    $self->{IsSpinning} = shift;
  }
  return $self->{IsSpinning};
}

=item B<spin_speed>

Spin speed of the polarimeter in deg/sec. If set, the C<is_spinning>
flag is set to true automatically.

 $pol->spin_speed( 2 );
 $speed = $pol->spin_speed;

=cut

sub spin_speed {
  my $self = shift;
  if (@_) {
    $self->{SpinSpeed} = shift;
    $self->is_spinning( 1 );
  }
  return $self->{SpinSpeed};
}

=item B<discrete_angles>

List of discrete angles to be used during the observation. Angles
must be C<Astro::Coords::Angle> objects.

  $pol->discrete_angles( @pa );
  @pa = $pol->discrete_angles();

Automatically sets C<is_spinning> to false.

=cut

sub discrete_angles {
  my $self = shift;
  if (@_) {
    @{$self->{DiscreteAngles}} = @_;
    $self->is_spinning( 0 );
  }
  return @{$self->{DiscreteAngles}};
}

=item B<steps_per_rotation>

If we are not spinning, calculates the number of steps in a rotation
if the angles are all monotonically increasing. Returns 0 if the
angles are not monotonically increasing and undef if the configuration
is for a spinning polarimeter.

Does not check to make sure that a full 360 deg rotation is requested
or that the first angle is 0. This means that angles of 0, 22.5, 45,
67.5 will return "16" as will 22.5 and 45.

Returns 0 if there are less than 2 angles.

=cut

sub steps_per_rotation {
  my $self = shift;
  return undef if $self->is_spinning;
  my @pa = $self->discrete_angles;
  return 0 unless scalar(@pa) > 1;

  # check for increasing monotonicity
  my $refdiff = $pa[1]->degrees - $pa[0]->degrees;

  if ($refdiff > 0) { # must increase
    for my $i ( 1.. $#pa ) {
      my $diff = $pa[$i]->degrees - $pa[$i-1]->degrees;
      # trap rounding errors
      if (abs($diff - $refdiff) > 0.1) {
        $refdiff = undef;
        last;
      }
    }
  } else {
    $refdiff = undef;
  }
  return 0 unless defined $refdiff;

  return (360 / $refdiff );

}

=item B<system>

Coordinate system for which angles are to be specified and reported.

  $sys = $pol->system();

These should match the TCS definitions.

=cut

sub system {
  my $self = shift;
  if (@_) {
    $self->{System} = uc(shift);
  }
  return $self->{System};
}

=item B<motion>

Control when the state of the polarimeter is allowed to change.
If C<is_spinning> is true this value will always be "ONCE" and
can not be overridden. For step and integrate mode the default
value is "GROUP".

 $motion = $pol->motion;
 $pol->motion( "GROUP" );

=cut

sub motion {
  my $self = shift;
  if (@_) {
    $self->{Motion} = shift;
  }
  return "ONCE" if $self->is_spinning;
  return $self->{Motion} if defined $self->{Motion};
  return "GROUP";
}

=item B<stringify>

Convert object to XML representation.

=cut

sub stringify {
  my $self = shift;
  my %args = @_;

  my $xml = '';
  $xml .= "<". $self->getRootElementName . ">\n";

  # Version declaration
  $xml .= $self->_introductory_xml();

  # See if we are spinning
  my $is_spin = $self->is_spinning;

  # Always have a POL_SPIN element
  $xml .= "<POL_SPIN \n";
  
  if ($is_spin) {
    $xml .= "  NAME=\"CONSTANT\"\n";
  } else {
    $xml .= "  NAME=\"STOP_START\"\n";
  }
  $xml .= "  MOTION=\"". $self->motion ."\"\n";
  $xml .= "  SYSTEM=\"". $self->system ."\" >\n";

  # fill in the angles or speed
  if ($is_spin) {
    my $speed = $self->spin_speed;
    throw JAC::OCS::Config::Error::FatalError("No spin speed defined for pol configuration")
      unless defined $speed;
    $xml .= "<POL_SPD>$speed</POL_SPD>\n";
  } else {
    # if the angles are monotonically increasing
    # we can simplify the representation
    my $steps_per_rot = $self->steps_per_rotation;
    if (defined $steps_per_rot && $steps_per_rot > 0) {
      $xml .= "<STEPS_PER_ROT>$steps_per_rot</STEPS_PER_ROT>\n";
    } else {
      my @pa = $self->discrete_angles;
      throw JAC::OCS::Config::Error::FatalError("Attempting to write a step and integrate pol configuration without specifying any angles") unless @pa;

      for my $ang (@pa) {
        $xml .= pa_to_xml( $ang );
      }
    }
  }
  $xml .= "</POL_SPIN>\n";
  $xml .= "</". $self->getRootElementName .">\n";
  return ($args{NOINDENT} ? $xml : indent_xml_string( $xml ));
}

=back

=head2 Class Methods

=over 4

=item B<dtdrequires>

Returns the names of any associated configurations required for this
configuration to be used in a full OCS_CONFIG. The POL configuration
does not require any other elements.

  @requires = $cfg->dtdrequires();

=cut

sub dtdrequires {
  return ();
}

=item B<getRootElementName>

Return the name of the _CONFIG element that should be the root
node of the XML tree corresponding to the POL config.

 @names = $h->getRootElementName;

=cut

sub getRootElementName {
  return( "POL_CONFIG" );
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_process_dom>

Using the C<_rootnode> node referring to the top of the POL XML,
process the DOM tree and extract all the coordinate information.

 $self->_process_dom;

Populates the object with the extracted results.

=cut

sub _process_dom {
  my $self = shift;

  # Find all the header items
  my $el = $self->_rootnode;

  # Everything is inside a POL_SPIN element
  my $pol_spin = find_children( $el, "POL_SPIN", min=>1, max=>1);

  # attributes control expected content of POL_SPIN
  my %args = find_attr( $pol_spin, "NAME","MOTION","SYSTEM");

  if ($args{NAME} eq 'CONSTANT') {

    my $speed = get_pcdata( $pol_spin, "POL_SPD" );
    $self->spin_speed( $speed );

    throw JAC::OCS::Config::Error::FatalError("Looking for continuous spin POL_CONFIG but did not find rotation speed")
      unless defined $speed;

  } elsif ($args{NAME} eq 'STOP_START') {

    # Can be either an array of PA or a STEPS_PER_ROT element
    my $s_per_rot = find_children( $pol_spin, "STEPS_PER_ROT",
                                   min => 0, max=>1);

    my @pa;
    if (defined $s_per_rot) {
      my $nsteps = get_pcdata( $pol_spin, "STEPS_PER_ROT" );

      # convert to position angles
      my $delta = 360.0 / $nsteps;
      @pa = map { Astro::Coords::Angle->new($delta * $_,
                                            units => 'deg') } 0..($nsteps-1);

      print "Delta = $delta nsteps=$nsteps\n";
    } else {
      @pa = find_pa( $pol_spin );
    }

    throw JAC::OCS::Config::Error::FatalError("Parsing Stop/Start POL_CONFIG but found no angle definitions") unless @pa;

    # store the angles
    $self->discrete_angles( @pa );

  } else {
    throw JAC::OCS::Config::Error::FatalError("Unknown name '$args{NAME}' in POL_SPIN attributes");
  }

  $self->motion( $args{MOTION} );
  $self->system( $args{SYSTEM} );

  return;
}

=back

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The JOS XML configuration specification is documented in OCS/ICD/017
with a DTD available at
http://docs.jach.hawaii.edu/JCMT/OCS/ICD/017/rover.dtd.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) 2007 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
