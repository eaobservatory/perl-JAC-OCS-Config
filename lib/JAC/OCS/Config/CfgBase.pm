package JAC::OCS::Config::CfgBase;

=head1 NAME

JAC::OCS::Config::CfgBase - Base class for config sub-systems

=head1 SYNOPSIS

  use JAC::OCS::Config::CfgBase;

=head1 DESCRIPTION

This class provides a base implementation for all the Config
sub-systems that are configured using XML. It is used by all the OCS
subsystems (everything that has a C<_CONFIG> element within an
C<OCS_CONFIG> root element).

=cut

use strict;
use Carp;
use warnings;
use XML::LibXML;

use JAC::OCS::Config::Error;

use vars qw/ $VERSION $INITKEY /;

# This is the key that sub-classes should use if they want
# to supply additional init values to the constructor
$INITKEY = '__init';

$VERSION = sprintf("%d.%03d", q$Revision$ =~ /(\d+)\.(\d+)/);

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new sub-system configuration object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::TCS( File => $file );
  $cfg = new JAC::OCS::Config::TCS( XML => $xml );
  $cfg = new JAC::OCS::Config::TCS( DOM => $dom );

The XML must contain an C<XXX_CONFIG> element corresponding to the
subclass.

Other optional keys are:

  validation - Boolean indicating whether to enable validation in XML
               parse. Important if you are relying on default values
               for attributes.

A special key (C<$JAC::OCS::Config::CfgBase::INITKEY>) can be supplied
by a subclass to provide additional, sub-system specific
initialisation keys. It should be a reference to a hash.

The method will throw a BadArgs exception if the arguments
are invalid (this may change), and a FatalError if no arguments are
supplied.

=cut

sub new {
  my $proto = shift;
  my $class = ref($proto) || $proto;

  # Read the arguments
  my %args = @_;

  my %extra;
  %extra = %{ $args{$INITKEY} }
    if exists $args{$INITKEY};

  # Create the object
  my $cfg = bless {
		   Parser => undef,
		   Tree => undef,
		   ConfigNode => undef,
		   FileName => undef,
		   DTDValidation => 1,
		   %extra
		  }, $class;

  # Store options
  for my $key (qw/ validation / ) {
    my $method = "_" . $key;
    $cfg->$method( $args{$key} ) if exists $args{$key};
  }

  # process the arguments
  if (exists $args{DOM} && defined $args{DOM}) {
    $cfg->_import_dom( $args{DOM} );
  } elsif (exists $args{XML} && defined $args{XML}) {
    $cfg->_import_xml_string( $args{XML} );
  } elsif (exists $args{File} && defined $args{File}) {
    $cfg->_import_xml_file( $args{File} );
  } elsif (%args) {
    throw JAC::OCS::Config::Error::BadArgs("Arguments supplied to constructor but not recognized");
  } else {
    throw JAC::OCS::Config::Error::FatalError("Must supply arguments to constructor\n");
  }
  return $cfg;
}

=head2 Accessor Methods

=over 4

=item B<filename>

Name of XML file used to construct the object (if any).

=cut

sub filename {
  my $self = shift;
  if (@_) { $self->{FileName} = shift; }
  return $self->{FileName};
}

=item B<_validation>

Indicate whether the parser should use DTD validation or not. Default
is to enable validation.

=cut

sub _validation {
  my $self = shift;
  if (@_) { $self->{DTDValidation} = shift; }
  return $self->{DTDValidation};
}

=item B<_parser>

The C<XML::LibXML> object associated with the tree. Not defined
if a DOM was used to instantiate the object.

=cut

sub _parser {
  my $self = shift;
  if (@_) {
    $self->{Parser} = shift;
  }
  return $self->{Parser};
}

=item B<_tree>

Parse tree associated with the XML used to instantiate the
object. Does not necessarily refer to the beginning of the
configuration XML segment of the parse tree (will normally refer to
the beginning of whatever XML was passed into the constructor).

=cut

sub _tree {
  my $self = shift;
  if (@_) { $self->{Tree} = shift; }
  return $self->{Tree};
}

=item B<_rootnode>

Node in the parse tree corresponding to the start of the configuration
XML (the XXX_CONFIG element).

=cut

sub _rootnode {
  my $self = shift;
  if (@_) { $self->{ConfigNode} = shift; }
  return $self->{ConfigNode};
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_import_xml_file>

Open a file and read the contents into the object. Called from the object
constructor. Calls C<_import_xml_string>.

 $self->_import_xml_file( $filename );

=cut

sub _import_xml_file {
  my $self = shift;
  my $file = shift;
  open my $fh, "< $file" || croak "Error opening XML file $file : $!";
  local $/ = undef;
  my $xml = <$fh>;
  close($fh) or croak "Error closing XML file $file : $!";

  $self->_import_xml_string( $xml );
  $self->filename( $file );
}

=item B<_import_xml_string>

Import a string containing the subsystem XML into the object.
Called from the object constructor or from C<_import_xml_file>.

  $self->_import_xml_string( $string );

=cut

sub _import_xml_string {
  my $self = shift;
  my $xml = shift;

  # create new parser
  my $parser = new XML::LibXML;
  print "Validation : ". $self->_validation . "\n";
  $parser->validation( $self->_validation );
  $self->_parser( $parser );

  # Allow the parser to fail
  my $tree = $parser->parse_string( $xml );

  $self->_import_dom( $tree );

}

=item B<_import_dom>

Import the DOM (created by C<XML::LibXML>) into the object.
Throws an exception if Config information can not be found in the
tree.

  $self->_import_dom( $tree );

Uses the getRootElementName method (in the subclass) to determine which
CONFIG elements are actually useful (and sets the first matching node
into the _rootnode attribute). Calls subclasses _process_dom method.

=cut

sub _import_dom {
  my $self = shift;
  my $tree = shift;

  # Get the root element 
  my @elements = $self->getRootElementName();
  my @xpath = join(" | ", map { "//$_" } @elements);

  # Now look for the TCS information
  my @nodes = $tree->findnodes(@xpath);

  croak "DOM contains multiple configurations!"
    if scalar(@nodes) > 1;

  croak "DOM contains no configurations!"
    if !scalar(@nodes);

  # found some configuration XML. Store it
  $self->_tree( $tree );
  $self->_rootnode( $nodes[0] );
  $self->_process_dom();
}

=item B<_get_pcdata>

Given an element and a tag name, find the element corresponding to
that tag and return the PCDATA entry from the last matching element.

 $pcdata = $msb->_get_pcdata( $el, $tag );

Convenience wrapper.

Returns C<undef> if the element can not be found.

Returns C<undef> if the element can be found but does not contain
anything (eg E<lt>targetName/E<gt>).

Duplicated from C<OMP::MSB>. If this version is modified please propagate
the change back to C<OMP::MSB>.

=cut

sub _get_pcdata {
  my $self = shift;
  my ($el, $tag ) = @_;
  my @matches = $el->getChildrenByTagName( $tag );
  my $pcdata;
  if (@matches) {
    my $child = $matches[-1]->firstChild;
    # Return undef if the element contains no text children
    return undef unless defined $child;
    $pcdata = $child->toString;
  }
  return $pcdata;
}

=cut

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The TCS XML configuration specification is documented in OCS/ICD/006
with a DTD available at
L<http://www.jach.hawaii.edu/JACdocs/JCMT/OCS/ICD/006/tcs.dtd>. A
schema is also available as part of the TOML definition used by the
JAC Observing Tool, but note that the XML dialects differ in their uses
even though they use the same low-level representation of an astronomical
target.

=head1 HISTORY

This code was originally part of the C<OMP::MSB> class and was then
extracted into a separate C<TOML::TCS> module. During work on the new
ACSIS translator it was felt that a Config namespace was more correct
and so the C<TOML> namespace was deprecated.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright 2002-2004 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
