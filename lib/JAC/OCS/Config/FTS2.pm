package JAC::OCS::Config::FTS2;

=head1 NAME

JAC::OCS::Config::FTS2 - Parse and modify OCS FTS2 configurations

=head1 SYNOPSIS

  use JAC::OCS::Config::FTS2;

  $fts2 = new JAC::OCS::Config::FTS2(File => 'fts2.ent');

  if ($fts2->is_rapid_scan()) {
    $scan_spd = $fts2->scan_spd();
  }

=head1 DESCRIPTION

This class can be used to parse and modify the header configuration
information present in the FTS2_CONFIG element of an OCS configuration.

=cut

use 5.006;
use strict;
use Carp;
use warnings;
use XML::LibXML;
use Astro::Coords::Angle;

use JAC::OCS::Config::Error qw| :try |;

use JAC::OCS::Config::XMLHelper qw(
                                   find_children
                                   find_attr
                                   indent_xml_string
                                   get_this_pcdata
                                  );
use JAC::OCS::Config::TCS::Generic qw (
                                        find_pa
                                        pa_to_xml
                                     );

use base qw/ JAC::OCS::Config::CfgBase /;

use vars qw/ $VERSION @VALID_SCAN_MODES @VALID_SCAN_DIRECTIONS /;

$VERSION = "0.01";

=head1 CONSTANTS

=over 4

=item B<@VALID_SCAN_MODES>

Gives a list of the scan modes permitted by the DTD.

=cut

@VALID_SCAN_MODES = qw/RAPID_SCAN STEP_AND_INTEGRATE ZPD_MODE/;

=item B<@VALID_SCAN_DIRECTIONS>

An array of scan directions as specified by the DTD.

=cut

@VALID_SCAN_DIRECTIONS = qw/DIR_LEFT DIR_ARBITRARY DIR_RIGHT/;

=back

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new FTS2 configuration object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::FTS2(File => $file);
  $cfg = new JAC::OCS::Config::FTS2(XML => $xml);
  $cfg = new JAC::OCS::Config::FTS2(DOM => $dom);

The method will die if no arguments are supplied.

=cut

sub new {
  my $self = shift;

  # Now call base class with all the supplied options + extra initialiser.
  return $self->SUPER::new(@_,
                            $JAC::OCS::Config::CfgBase::INITKEY => {
                                                                   }
                          );
}

=back

=head2 Accessor Methods

=over 4

=item B<tasks>

Name of the task that would be involved in reading this config.

  @tasks = $cfg->tasks;

=cut

sub tasks {
  my $self = shift;
  return 'FTS2';
}

=item B<scan_mode>

The scan mode must be one of those listed in C<@VALID_SCAN_MODES>.

=cut

sub scan_mode {
  my $self = shift;
  if (@_) {
    my $mode = shift;
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_MODE ' . $mode . ' does not exist')
      unless grep {$_ eq $mode} @VALID_SCAN_MODES;
    $self->{'ScanMode'} = $mode;
  }
  return $self->{'ScanMode'};
}

=item B<scan_dir>

The scan direction must be one of those listed in C<@VALID_SCAN_DIRECTIONS>.

=cut

sub scan_dir {
  my $self = shift;
  if (@_) {
    my $direction = shift;
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_DIRECTION ' . $direction . ' does not exist')
      unless grep {$_ eq $direction} @VALID_SCAN_DIRECTIONS;
    $self->{'ScanDirection'} = $direction;
  }
  return $self->{'ScanDirection'};
}

=item B<scan_origin>

The scan origin is in units of mm.

=cut

sub scan_origin {
  my $self = shift;
  if (@_) {
    $self->{'ScanOrigin'} = shift;
  }
  return $self->{'ScanOrigin'};
}

=item B<scan_spd>

The scan speed is in units of mm/s.

=cut

sub scan_spd {
  my $self = shift;
  if (@_) {
    $self->{'ScanSpeed'} = shift;
  }
  return $self->{'ScanSpeed'};
}

=item B<scan_length>

The scan length is in units of mm.

=cut

sub scan_length {
  my $self = shift;
  if (@_) {
    $self->{'ScanLength'} = shift;
  }
  return $self->{'ScanLength'};
}

=item B<step_dist>

The step distance is in units of mm.

=cut

sub step_dist {
  my $self = shift;
  if (@_) {
    $self->{'StepDistance'} = shift;
  }
  return $self->{'StepDistance'};
}


=item B<stringify>

Convert object to XML representation.

=cut

sub stringify {
  my $self = shift;
  my %args = @_;

  my $xml = '';
  $xml .= "<". $self->getRootElementName . ">\n";

  # Version declaration
  $xml .= $self->_introductory_xml();

  # Required Elements:
  # Scan Mode
  $xml .= '<SCAN_MODE VALUE="' . $self->scan_mode() . '" />' . "\n";

  # Scan Direction
  $xml .= '<SCAN_DIR VALUE="' . $self->scan_dir() . '" />' . "\n";

  # Scan Origin
  $xml .= '<SCAN_ORIGIN UNIT="mm">' . $self->scan_origin() . "</SCAN_ORIGIN>\n";

  # Optional Elements:
  # Scan Speed
  my $speed = $self->scan_spd();
  $xml .= '<SCAN_SPD UNIT="mm/s">' . $speed . "</SCAN_SPD>\n"
    if defined $speed;

  # Scan Length
  my $length = $self->scan_length();
  $xml .= '<SCAN_LENGTH UNIT="mm">' . $length . "</SCAN_LENGTH>\n"
    if defined $length;

  # Step Distance
  my $step = $self->step_dist();
  $xml .= '<STEP_DIST UNIT="mm">' . $step . "</STEP_DIST>\n"
    if defined $step;

  $xml .= "</". $self->getRootElementName .">\n";
  return ($args{NOINDENT} ? $xml : indent_xml_string( $xml ));
}

=back

=head2 Class Methods

=over 4

=item B<dtdrequires>

Returns the names of any associated configurations required for this
configuration to be used in a full OCS_CONFIG. The FTS2 configuration
requires knowledge of the associated instrument setup.

  @requires = $cfg->dtdrequires();

=cut

sub dtdrequires {
  return ('instrument_setup');
}

=item B<getRootElementName>

Return the name of the _CONFIG element that should be the root
node of the XML tree corresponding to the FTS2 config.

 @names = $h->getRootElementName;

=cut

sub getRootElementName {
  return( "FTS2_CONFIG" );
}

=item B<is_rapid_scan>

Returns true if the scan mode is RAPID_SCAN.

=cut

sub is_rapid_scan {
  my $self = shift;
  return $self->scan_mode() eq 'RAPID_SCAN';
}

=item B<is_step_and_integrate>

Returns true if the scan mode is STEP_AND_INTEGRATE.

=cut

sub is_step_and_integrate {
  my $self = shift;
  return $self->scan_mode() eq 'STEP_AND_INTEGRATE';
}

=item B<is_zpd_mode>

Returns true if the scan mode is ZPD_MODE.

=cut

sub is_zpd_mode {
  my $self = shift;
  return $self->scan_mode() eq 'ZPD_MODE';
}

=item B<is_left_direction>

Returns true if the scan direction is DIR_LEFT.

=cut

sub is_left_direction {
  my $self = shift;
  return $self->scan_dir() eq 'DIR_LEFT';
}

=item B<is_arbitrary_direction>

Returns true if the scan direction is DIR_ARBITRARY.

=cut

sub is_arbitrary_direction {
  my $self = shift;
  return $self->scan_dir() eq 'DIR_ARBITRARY';
}

=item B<is_right_drection>

Returns true if the scan direction is DIR_RIGHT.

=cut

sub is_right_direction {
  my $self = shift;
  return $self->scan_dir() eq 'DIR_RIGHT';
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_process_dom>

Using the C<_rootnode> node referring to the top of the POL XML,
process the DOM tree and extract all the coordinate information.

 $self->_process_dom;

Populates the object with the extracted results.

=cut

sub _process_dom {
  my $self = shift;

  # Find all the header items
  my $el = $self->_rootnode;

  # Required Elements:
  # Scan Mode
  my $scan_mode = find_children($el, 'SCAN_MODE', min => 1, max => 1);
  do {
    my %attr = find_attr($scan_mode, q/VALUE/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_MODE requires a VALUE')
      unless defined $attr{'VALUE'};

    $self->scan_mode($attr{'VALUE'});
  };

  # Scan Direction
  # Perhaps not relevant in ZPD_MODE but the DTD requires it.
  my $scan_dir = find_children($el, 'SCAN_DIR', min => 1, max => 1);
  do {
    my %attr = find_attr($scan_dir, q/VALUE/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_DIR requires a VALUE')
      unless defined $attr{'VALUE'};

    $self->scan_dir($attr{'VALUE'});
  };

  # Scan Origin
  my $scan_origin = find_children($el, 'SCAN_ORIGIN', min => 1, max => 1);
  do {
    my %attr = find_attr($scan_origin, q/UNIT/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_ORIGIN should have UNIT mm')
      unless defined $attr{'UNIT'} and $attr{'UNIT'} eq 'mm';

    my $origin = get_this_pcdata($scan_origin);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_ORIGIN is empty')
      unless defined $origin;

    $self->scan_origin($origin);
  };


  # Optional Elements:
  # Scan Speed
  # Should we check that we are not in step and integrate mode?
  my $scan_spd = find_children($el, 'SCAN_SPD', min => 0, max => 1);
  if (defined $scan_spd) {
    my %attr = find_attr($scan_spd, q/UNIT/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_SPD should have UNIT mm/s')
      unless defined $attr{'UNIT'} and $attr{'UNIT'} eq 'mm/s';

    my $speed = get_this_pcdata($scan_spd);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_SPD is empty')
      unless defined $speed;

    $self->scan_spd($speed);
  }

  # Scan Length
  my $scan_length = find_children($el, 'SCAN_LENGTH', min => 0, max => 1);
  if (defined $scan_length) {
    my %attr = find_attr($scan_length, q/UNIT/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_LENGTH should have UNIT mm')
      unless defined $attr{'UNIT'} and $attr{'UNIT'} eq 'mm';

    my $length = get_this_pcdata($scan_length);
    throw JAC::OCS::Config::Error::FatalError('FTS2 SCAN_LENGTH is empty')
      unless defined $length;

    $self->scan_length($length);
  }

  # Step Distance
  my $step_dist = find_children($el, 'STEP_DIST', min => 0, max => 1);
  if (defined $step_dist) {
    my %attr = find_attr($step_dist, q/UNIT/);
    throw JAC::OCS::Config::Error::FatalError('FTS2 STEP_DIST should have UNIT mm')
      unless defined $attr{'UNIT'} and $attr{'UNIT'} eq 'mm';

    my $step = get_this_pcdata($step_dist);
    throw JAC::OCS::Config::Error::FatalError('FTS STEP_DIST is empty')
      unless defined $step;

    $self->step_dist($step);
  }

  return;
}

=back

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The JOS XML configuration specification is documented in OCS/ICD/019
with a DTD available at
http://docs.jach.hawaii.edu/JCMT/OCS/ICD/019/fts2config.dtd.

=cut

1;
