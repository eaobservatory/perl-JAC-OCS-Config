package JAC::OCS::Config::ACSIS::CubeList;

=head1 NAME

JAC::OCS::Config::ACSIS - Parse and modify OCS ACSIS cube configurations

=head1 SYNOPSIS

  use JAC::OCS::Config::ACSIS::CubeList;

  $cfg = new JAC::OCS::Config::ACSIS::CubeList( DOM => $dom);

=head1 DESCRIPTION

This class can be used to parse and modify the ACSIS cube configuration
information present in the C<cube_list> element of an OCS configuration.

Fundamentally, contains an array of cube objects.

=cut

use 5.006;
use strict;
use Carp;
use warnings;
use XML::LibXML;

use JAC::OCS::Config::Error qw| :try |;

# Parsing spherSystem
use JAC::OCS::Config::TCS::BASE;

use JAC::OCS::Config::XMLHelper qw( find_attr find_attrs_and_pcdata
				    find_children find_attr_child 
				    get_this_pcdata get_pcdata find_range
				  );


use base qw/ JAC::OCS::Config::CfgBase /;

use vars qw/ $VERSION /;

$VERSION = sprintf("%d.%03d", q$Revision$ =~ /(\d+)\.(\d+)/);

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new CubeList configuration object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::ACSIS::CubeList( File => $file );
  $cfg = new JAC::OCS::Config::ACSIS::CubeList( XML => $xml );
  $cfg = new JAC::OCS::Config::ACSIS::CubeList( DOM => $dom );

The method will die if no arguments are supplied.

=cut

sub new {
  my $self = shift;

  # Now call base class with all the supplied options +
  # extra initialiser
  return $self->SUPER::new( @_, 
			    $JAC::OCS::Config::CfgBase::INITKEY => { 
								    CUBES => [],
								   }
			  );
}

=back

=head2 Accessor Methods

=over 4

=item B<cubes>

Array of C<JAC::OCS::Config::ACSIS::Cube> objects.

=cut

sub cubes {
  my $self = shift;
  if (@_) {
    # Should check class
    for my $c (@_) {
      throw JAC::OCS::Config::Error::BadArgs("Class must be JAC::OCS::Config::ACSIS::Cube objects")
	unless UNIVERSAL::isa($c, "JAC::OCS::Config::ACSIS::Cube");
    }
    @{$self->{CUBES}} = @_;
  }
  return @{$self->{CUBES}};
}

=back

=head2 Class Methods

=over 4

=item B<getRootElementName>

Return the name of the _CONFIG element that should be the root
node of the XML tree corresponding to the ACSIS cube config.

 @names = $h->getRootElementName;

=cut

sub getRootElementName {
  return( "cube_list" );
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_process_dom>

Using the C<_rootnode> node referring to the top of the Instrument XML,
process the DOM tree and extract all the coordinate information.

 $self->_process_dom;

Populates the object with the extracted results.

=cut

sub _process_dom {
  my $self = shift;

  # Find all the header items
  my $el = $self->_rootnode;

  # need to get all the cube elements
  my @cxml = find_children( $el, "cube", min => 1 );

  my @cubes;

  # Now extract information from each cube
  for my $c (@cxml) {
    my $id = find_attr( $c, "id" );

    # group centre may or may not exist
    my $gcen = find_children( $c, "group_centre", max => 1);
    my $coords;
    if ($gcen) {
      # mandatory spherSystem
      # but we should use the TCS XML parser to decode this
      # and convert it to Astro::Coords object
      # This is all done already in
      #    JAC::OCS::Config::TCS::BASE->_extract_coord_info
      # This could get hairy. For now, just use it and hope the
      # interface doesn't change. This could be factored out into
      # a standard TCS/Generic helper function since it is a class method
      $coords = JAC::OCS::Config::TCS::BASE->_extract_coord_info($gcen);

    }

    # pixel size
    my %attr;
    (my $x_pix_size, %attr) = find_attrs_and_pcdata( $c, "x_pix_size" );
    my $x_pix_size_units = $attr{units};
    (my $y_pix_size, %attr) = find_attrs_and_pcdata( $c, "y_pix_size" );
    my $y_pix_size_units = $attr{units};

    # offset
    my $x_offset = get_pcdata( $c, "x_offset" );
    my $y_offset = get_pcdata( $c, "y_offset" );

    # Number of pixels
    my $x_npix = get_pcdata( $c, "x_npix" );
    my $y_npix = get_pcdata( $c, "y_npix" );

    # projection
    my $projection = find_attr_child( $c, "projection", "type");

    # regridding function
    my $grid_function = find_attr_child( $c, "grid_function", "type");

    # TCS coordinate system for regridding (AZEL or TRACKING)
    my $tcs_coord = find_attr_child( $c, "tcs_coord", "type");

    # Smoothing radius (in arcsec)
    my $smoothing_rad = get_pcdata( $c, "smoothing_rad" );

    # data source
    my $dsrc = find_children( $c, "data_source", min => 1, max => 1);

    my $spw = find_attr_child( $dsrc, "spw_ref", "ref" );
    my $ds_range = find_range( $dsrc );

  }

  # store the cubes
  $self->cubes( @cubes );

}

=back

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The ACSIS XML configuration specification is documented in
OCS/ICD/005 with a DTD available at
http://www.jach.hawaii.edu/JACdocs/JCMT/OCS/ICD/005/acsis.dtd.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright 2004 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
