package JAC::OCS::Config::ACSIS::ProcessLinks;

=head1 NAME

JAC::OCS::Config::ACSIS - Parse and modify OCS ACSIS process link configurations

=head1 SYNOPSIS

  use JAC::OCS::Config::ACSIS::ProcessLinks;

  $cfg = new JAC::OCS::Config::ACSIS::ProcessLinks( DOM => $dom);

=head1 DESCRIPTION

This class can be used to parse and modify the ACSIS process link configuration
information present in the C<process_links> element of an OCS configuration.

=cut

use 5.006;
use strict;
use Carp;
use warnings;
use XML::LibXML;

use JAC::OCS::Config::Error qw| :try |;
use JAC::OCS::Config::ACSIS::ProcessLink;

use JAC::OCS::Config::XMLHelper qw(
				   find_children
				   find_attr
				   indent_xml_string
				  );

use base qw/ JAC::OCS::Config::CfgBase /;

use vars qw/ $VERSION /;

$VERSION = sprintf("%d", q$Revision$ =~ /(\d+)/);

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new ProcessLinks configuration object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::ACSIS::ProcessLinks( File => $file );
  $cfg = new JAC::OCS::Config::ACSIS::ProcessLinks( XML => $xml );
  $cfg = new JAC::OCS::Config::ACSIS::ProcessLinks( DOM => $dom );

A blank object will be created if no arguments are supplied.

=cut

sub new {
  my $self = shift;

  # Now call base class with all the supplied options +
  # extra initialiser
  return $self->SUPER::new( @_, 
			    $JAC::OCS::Config::CfgBase::INITKEY => { 
				                                    ProcessLinks => [],
								   }
			  );
}

=back

=head2 Accessor Methods

=over 4

=item B<links>

Return a list of C<JAC::OCS::Config::ACSIS::ProcessLink> objects.

  @links = $pls->links();
  $pls->links( @links );

Note that you can add to the links or overwrite them all, you cannot change them.

=cut

sub links {
  my $self = shift;
  if (@_) {
      @{$self->{ProcessLinks}} = @_;
  }
  return @{$self->{ProcessLinks}};
}

=item B<addLink>

Add a C<JAC::OCS::Config::ACSIS::ProcessLink> object to the list of links.

  my $link = JAC::OCS::Config::ACSIS::ProcessLink(from_ref   => 'if_monitor',
						  from_event => 'if_data',
						  to_ref     => 'sync1',
						  to_event   => 'if_data');
  $pls->addLink( $link );

=cut

sub addLink {
  my $self = shift;
  if (@_) {
    push(@{$self->{ProcessLinks}}, @_);
  }
}

=item B<stringify>

Create XML representation of object.

=cut

sub stringify {
  my $self = shift;
  my %args = @_;

  my $xml = '';
  $xml .= "<". $self->getRootElementName . ">\n";

  # Version declaration
  $xml .= $self->_introductory_xml();

  my @links = $self->links;

  for my $link (@links) {
    $xml .= "<glish_link ";
    $xml .= "from_ref=\"".$link->from_ref ."\" ";
    $xml .= "from_event=\"".$link->from_event ."\" ";
    $xml .= "to_ref=\"".$link->to_ref ."\" ";
    $xml .= "to_event=\"".$link->to_event ."\"/>\n";
  }

  $xml .= "</". $self->getRootElementName .">\n";
  return ($args{NOINDENT} ? $xml : indent_xml_string( $xml ));
}

=back

=head2 Class Methods

=over 4

=item B<getRootElementName>

Return the name of the _CONFIG element that should be the root
node of the XML tree corresponding to the ACSIS process link config.

 @names = $h->getRootElementName;

=cut

sub getRootElementName {
  return( "process_links" );
}

=item B<createFromNumbers>

Factorymethod to create a ProcessLinks object from a given number of
sync_tasks, reducers and gridders. The number and names of monitors
are hard coded and there is always one specwriter.

  my $numSynctasks = 8;
  my $numReducers = 8;
  my $numGridders = 1;
  my $pl = JAC::OCS::Config::ACSIS::ProcessLinks::createFromNumbers($numSynctasks, $numReducers, $numGridders);

=cut

sub createFromNumbers {
  my ($numSynctasks, $numReducers, $numGridders) = @_;

  my $pls = new JAC::OCS::Config::ACSIS::ProcessLinks();
  my $linkCl = "JAC::OCS::Config::ACSIS::ProcessLink";

  my %monitors = (
      if_monitor    => 'if_data',
      rts_monitor   => 'rts_data',
      fe_monitor    => 'fe_data',
      rover_monitor => 'rover_data',
      ws_monitor    => 'weather_data',
      ant_monitor   => 'ant_data',
  );

  my $reducercounter = 1;
  # For every sync_task: links to monitors and reducers
  for my $i (1..$numSynctasks) {
    my $sync = 'sync' . $i;

    # create a link from every monitor to this sync_task
    for my $monitor (keys %monitors) {
      $pls->addLink($linkCl->new(from_ref   => $monitor,
				 from_event => $monitors{$monitor},
				 to_ref     => $sync,
				 to_event   => $monitors{$monitor}));
    };

    # create a link from one corr_monitor to this sync_task
    $pls->addLink($linkCl->new(from_ref   => 'corr_monitor' . $i,
			       from_event => 'corr_data',
			       to_ref     => $sync,
			       to_event   => 'corr_data'));

    # create a link to the correct number of reducers
    # there is usually one reducer per sync_task, but it can be two
    for my $ri (1..int($numReducers / $numSynctasks)) {
      my $reducer = 'reducer' . $reducercounter++;
      my %args = (from_ref => $reducer, to_ref => $sync);
      for my $event ( qw( attach detach available ) ) {
	$pls->addLink($linkCl->new(%args, 
				   from_event => "reducer_target.$event",
				   to_event   => "sync_source.$event"));
      }
      $pls->addLink($linkCl->new(from_ref   => $sync,
				 from_event => 'data_4_' . $reducer,
				 to_ref     => $reducer,
				 to_event   => 'reducer_target.data'));
    };
  };

  # Links between reducers and gridders
  my @gridders = ('specwriter2', map { 'gridder'.$_ } (1..$numGridders));
  for my $ri (1..$numReducers) {
    my $reducer = 'reducer' . $ri;
    for my $gridder (@gridders) {
      my %args = (from_ref => $gridder, to_ref => $reducer);
      for my $event ( qw( attach detach available ) ) {
	  $pls->addLink($linkCl->new(%args,
				     from_event => "gridder_target.$event",
				     to_event   => "reducer_source.$event"));
      }
      $pls->addLink($linkCl->new(from_ref   => $reducer,
				 from_event => 'data_4_' . $gridder,
				 to_ref     => $gridder,
				 to_event   => 'gridder_target.data'));
    }
  };

  return $pls;
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_process_dom>

Using the C<_rootnode> node referring to the top of the Instrument XML,
process the DOM tree and extract all the coordinate information.

 $self->_process_dom;

Populates the object with the extracted results.

=cut

sub _process_dom {
  my $self = shift;

  # Find all the header items
  my $el = $self->_rootnode;

  # need to get all the rest_frequency elements.
  my @xmllinks = find_children( $el, "glish_link", min => 1 );

  my @links;
  for my $xmllink (@xmllinks) {
    my %attr = find_attr( $xmllink, "from_ref", "from_event", "to_ref", "to_event" );

    @links = (@links, new JAC::OCS::Config::ACSIS::ProcessLink(%attr));
  }

  # store the links
  $self->links( @links );

}

=back

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The ACSIS XML configuration specification is documented in
OCS/ICD/005 with a DTD available at
http://docs.jach.hawaii.edu/JCMT/OCS/ICD/005/acsis.dtd.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>, Walther Zwart E<lt>w.zwart@jach.hawaii.eduE<gt>

Copyright (C) 2004 Particle Physics and Astronomy Research Council.
Copyright (C) 2008 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
