package JAC::OCS::Config::ACSIS::Simulation;

=head1 NAME

JAC::OCS::Config::ACSIS - Parse and modify OCS ACSIS simulation configurations

=head1 SYNOPSIS

  use JAC::OCS::Config::ACSIS::Simulation;

  $cfg = new JAC::OCS::Config::ACSIS::Simulation( DOM => $dom);

=head1 DESCRIPTION

This class can be used to parse and modify the ACSIS simulation configuration
information present in the C<simulation> element of an OCS configuration.

=cut

use 5.006;
use strict;
use Carp;
use warnings;
use XML::LibXML;

use JAC::OCS::Config::Error qw| :try |;

use JAC::OCS::Config::XMLHelper qw(
                                   find_children
                                   find_attr
				   get_pcdata_multi
                                   indent_xml_string
                                  );

use base qw/ JAC::OCS::Config::CfgBase /;

use vars qw/ $VERSION /;

$VERSION = sprintf("%d", q$Revision$ =~ /(\d+)/);

# The keys present in the cloud xml and also mirrored directly
# into the internal cloud hash
my @CLOUD_KEYS = qw/
		    x_location y_location major_width minor_width 
		    position_angle z_location pos_z_width neg_z_width
		    amplitude
		    /;

# These are the non cloud tags
my @NONCLOUD_TAGS = qw/ noise refsky_temp load2_temp
			ambient_temp band_start_pos/;

=head1 METHODS

=head2 Constructor

=over 4

=item B<new>

Create a new ACSIS simulation object. An object can be created from
a file name on disk, a chunk of XML in a string or a previously created
DOM tree generated by C<XML::LibXML> (i.e. A C<XML::LibXML::Element>).

  $cfg = new JAC::OCS::Config::ACSIS::Simulation( File => $file );
  $cfg = new JAC::OCS::Config::ACSIS::Simulation( XML => $xml );
  $cfg = new JAC::OCS::Config::ACSIS::Simulation( DOM => $dom );

A blank simulation object can be created.

=cut

sub new {
  my $self = shift;

  # Now call base class with all the supplied options +
  # extra initialiser
  return $self->SUPER::new( @_,
                            $JAC::OCS::Config::CfgBase::INITKEY => {
                                                                    CLOUDS => [],
                                                                   }
                          );
}

=back

=head2 Accessor Methods

=over 4

=item B<clouds>

Returns array of cloud information stored as an array of references to
hashes. Keys in the hash are:

  spw_id
  x_location
  y_location
  major_width
  position_angle
  z_location
  pos_z_width
  neg_z_width
  amplitude

There is no Cloud object or attempt to combine x/y_location etc into unified elements (laziness).

  @clouds = $sim->clouds();

Can be used to set the cloud information

  $sim->clouds( @newclouds );

A reference to an array of hashes can also be used:

  $sim->clouds( \@newclouds );

And allows all the clouds to be cleared.

=cut

sub clouds {
  my $self = shift;
  if (@_) {
    if (ref($_[0]) eq 'ARRAY') {
      @{$self->{CLOUDS}} = @{$_[0]};
    } elsif (ref($_[0]) eq 'HASH') {
      @{$self->{CLOUDS}} = @_;
    } else {
      throw JAC::OCS::Config::Error::BadArgs( "Argument supplied to clouds() neither hash nor array ref");
    }
  }
  return @{ $self->{CLOUDS} };
}

=item B<noise>

Add noise to simulation? Boolean.

  $sim->noise( 1 );

=cut

sub noise {
  my $self = shift;
  if (@_) {
    $self->{NOISE} = shift;
  }
  return $self->{NOISE};
}

=item B<refsky_temp>

Temperature of sky.

=cut

sub refsky_temp {
  my $self = shift;
  if (@_) {
    $self->{REFSKY_TEMP} = shift;
  }
  return $self->{REFSKY_TEMP};
}

=item B<load2_temp>

Temperature of Load 2.

=cut

sub load2_temp {
  my $self = shift;
  if (@_) {
    $self->{LOAD2_TEMP} = shift;
  }
  return $self->{LOAD2_TEMP};
}

=item B<ambient_temp>

Temperature of ambient load.

=cut

sub ambient_temp {
  my $self = shift;
  if (@_) {
    $self->{AMBIENT_TEMP} = shift;
  }
  return $self->{AMBIENT_TEMP};
}

=item B<band_start_pos>

Band start position.

=cut

sub band_start_pos {
  my $self = shift;
  if (@_) {
    $self->{BAND_START_POS} = shift;
  }
  return $self->{BAND_START_POS};
}

=item B<filter_clouds>

Remove cloud definitions unless they have spectral window IDs that match
the supplied values.

  $sim->filter_clouds( "SPW1", "SPW2" );

Clouds that have no id are always retained (and they are associated with
the supplied filter ids in turn, cycling if necessary).

=cut

sub filter_clouds {
  my $self = shift;
  my @filter = @_;

  my @clouds = $self->clouds;
  my @out;
  my $pos = 0;

  for my $c (@clouds) {
    if (exists $c->{spw_id}) {
      # need to compare
      my $match;
      for my $cref (@filter) {
	if ($cref eq $c->{spw_id}) {
	  $match = 1;
	  last;
	}
      }
      push(@out, $c) if $match;

    } else {
      # keep it, and assign the current ID
      $c->{spw_id} = $filter[$pos];
      push(@out, $c);

      # increment the position, resetting as required
      $pos++;
      if ($pos > $#filter) {
	$pos = 0;
      }
    }
  }

  # store the filtered clouds
  $self->clouds( \@out );

}

=item B<stringify>

Create XML representation of object.

=cut

sub stringify {
  my $self = shift;
  my %args = @_;

  my $xml = '';

  $xml .= "<". $self->getRootElementName . ">\n";

  # Version declaration
  $xml .= $self->_introductory_xml();

  # clouds
  my @clouds = $self->clouds;
  for my $c (@clouds) {
    $xml .= "<cloud ". (exists $c->{spw_id} ? "spw_id=\"".$c->{spw_id}."\" " : ""). ">\n";
    for my $key (@CLOUD_KEYS) {
      if (exists $c->{$key}) {
	$xml .= "<$key>". $c->{$key} ."</$key>\n";
      }
    }
    $xml .= "</cloud>\n";
  }

  # boolean
  my $noise = $self->noise;
  $xml .= "<noise>". ($noise ? "YES" : "NO" ) . "</noise>\n";

  # scalars
  for my $method (@NONCLOUD_TAGS) {
    next if $method eq 'noise';
    my $value = $self->$method();
    if (defined $value) {
      $xml .= "<$method>$value</$method>\n";
    }
  }

  $xml .= "</". $self->getRootElementName . ">\n";

  return ($args{NOINDENT} ? $xml : indent_xml_string( $xml ));
}

=back

=head2 Class Methods

=over 4

=item B<getRootElementName>

Return the name of the _CONFIG element that should be the root
node of the XML tree corresponding to the ACSIS simulation config.

 @names = $h->getRootElementName;

=cut

sub getRootElementName {
  return( "simulation" );
}

=back

=begin __PRIVATE_METHODS__

=head2 Private Methods

=over 4

=item B<_process_dom>

Using the C<_rootnode> node referring to the top of the ACSIS_map XML,
process the DOM tree and extract all the coordinate information.

 $self->_process_dom;

Populates the object with the extracted results.

=cut

sub _process_dom {
  my $self = shift;

  # Find all the header items
  my $el = $self->_rootnode;

  # start with the clouds
  my @clnodes = find_children( $el, "cloud", min => 1 );

  my @clouds;
  for my $cel (@clnodes) {
    my %content = get_pcdata_multi( $cel, @CLOUD_KEYS);
    my $spwid = find_attr( $cel, "spw_id" );
    $content{spw_id} = $spwid if defined $spwid;
    push(@clouds, \%content);
  }
  $self->clouds( @clouds );

  # Rest are PC DATA
  my %global = get_pcdata_multi( $el, @NONCLOUD_TAGS );

  if (exists $global{noise}) {
    $self->noise( $global{noise} eq 'YES' ? 1 : 0 );
  }

  for my $tag (@NONCLOUD_TAGS) {
    next if $tag eq 'noise';
    $self->$tag( $global{$tag} ) if defined $global{$tag};
  }

  return;
}

=back

=end __PRIVATE_METHODS__

=head1 XML SPECIFICATION

The ACSIS XML configuration specification is documented in
OCS/ICD/005 with a DTD available at
http://www.jach.hawaii.edu/JACdocs/JCMT/OCS/ICD/005/acsis.dtd.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright 2004-2006 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
